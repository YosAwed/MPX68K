# 実装ステップバイステップガイド

## ステップ1: データ構造の整理

### 1.1. 変数の役割を明確化

現在の`scc.c`では、以下の変数が混在しています:

```c
// マウス関連（ポートA用）
extern signed char MouseX;
extern signed char MouseY;
extern BYTE MouseSt;
BYTE SCC_Dat[3];
BYTE SCC_DatNum;

// レジスタ（本来はポート別に分けるべき）
BYTE SCC_RegsA[16];  // ポートA用
BYTE SCC_RegsB[16];  // ポートB用
BYTE SCC_RegNumA;
BYTE SCC_RegSetA;
BYTE SCC_RegNumB;
BYTE SCC_RegSetB;
BYTE SCC_Vector;     // 共有

// シリアル通信関連（ポートB用に変更）
static SCC_SerialPort scc_port_a;  // → scc_port_b に変更
static SCC_SerialPort scc_port_b;  // 現在未使用
```

### 1.2. 修正方針

1. `scc_port_a`を`scc_port_b`に置き換える（シリアル通信はポートB）
2. マウス関連の変数はそのまま（ポートA専用）
3. レジスタは既に分離されているので、正しく使用する

## ステップ2: SCC_Write関数の修正

### 2.1. 現在のコード構造

```c
void FASTCALL SCC_Write(DWORD adr, BYTE data)
{
    if (adr>=0xe98008) return;
    
    if ((adr&7) == 1) {  // 0xE98001: ポートB コントロール
        if (SCC_RegSetB) {
            if (SCC_RegNumB == 5) {
                if (scc_port_a.mode == SCC_MODE_MOUSE_ONLY) {
                    // マウス処理（間違い：ポートBでマウス処理している）
                } else {
                    // シリアル通信処理
                }
            }
        }
    }
    else if ((adr&7) == 3) {  // 0xE98003: ポートB データ
        // シリアル通信データ送信
    }
    else if ((adr&7) == 5) {  // 0xE98005: ポートA コントロール
        // ポートAのレジスタ設定のみ
    }
    else if ((adr&7) == 7) {  // 0xE98007: ポートA データ
        // シリアル通信データ送信（間違い：ポートAでシリアル通信している）
    }
}
```

### 2.2. 修正後のコード

```c
void FASTCALL SCC_Write(DWORD adr, BYTE data)
{
    if (adr>=0xe98008) return;
    
    if ((adr&7) == 1) {  // 0xE98001: ポートB コントロール
        if (SCC_RegSetB) {
            if (SCC_RegNumB == 5) {
                // ポートBはシリアル通信専用
                if ((data & 2) && scc_port_b.connected) {
                    scc_port_b.tx_ready = 1;
                }
            } else if (SCC_RegNumB == 2) {
                SCC_Vector = data;
            }
            SCC_RegSetB = 0;
            SCC_RegsB[SCC_RegNumB] = data;
            SCC_RegNumB = 0;
        } else {
            if (!(data&0xf0)) {
                data &= 15;
                SCC_RegSetB = 1;
                SCC_RegNumB = data;
            } else {
                SCC_RegSetB = 0;
                SCC_RegNumB = 0;
            }
        }
    }
    else if ((adr&7) == 3) {  // 0xE98003: ポートB データ
        // シリアル通信のデータ送信（ポートB）
        if (scc_port_b.connected) {
            SCC_SendByte(&scc_port_b, data);
        }
    }
    else if ((adr&7) == 5) {  // 0xE98005: ポートA コントロール
        if (SCC_RegSetA) {
            if (SCC_RegNumA == 5) {
                // ポートAはマウス専用
                // RTS立ち上がり検出
                int rtsRising = (!(SCC_RegsA[5]&2)) && (data&2);
                int rxEnabled = (SCC_RegsA[3]&1);
                // ダブルクリック修正: データが無い時だけ生成
                if (rtsRising && rxEnabled && (!SCC_DatNum)) {
                    Mouse_SetData();
                    SCC_DatNum = 3;
                    SCC_Dat[2] = MouseSt;
                    SCC_Dat[1] = (BYTE)MouseX;
                    SCC_Dat[0] = (BYTE)MouseY;
                }
            } else if (SCC_RegNumA == 2) {
                SCC_RegsB[2] = data;
                SCC_Vector = data;
            } else if (SCC_RegNumA == 9) {
                SCC_RegsB[9] = data;
            }
            SCC_RegSetA = 0;
            SCC_RegsA[SCC_RegNumA] = data;
            SCC_RegNumA = 0;
        } else {
            data &= 15;
            if (data) {
                SCC_RegSetA = 1;
                SCC_RegNumA = data;
            } else {
                SCC_RegSetA = 0;
                SCC_RegNumA = 0;
            }
        }
    }
    else if ((adr&7) == 7) {  // 0xE98007: ポートA データ
        // ポートAはマウス専用なので、データ書き込みは無視
        // （X68000側からマウスにデータを送ることはない）
    }
}
```

## ステップ3: SCC_Read関数の修正

### 3.1. 修正後のコード

```c
BYTE FASTCALL SCC_Read(DWORD adr)
{
    BYTE ret = 0;
    if (adr>=0xe98008) return ret;
    
    if ((adr&7) == 1) {  // 0xE98001: ポートB コントロール
        if (!SCC_RegNumB) {
            // ステータス読み取り
            ret = 0;
            if (scc_port_b.tx_ready) ret |= 4;  // 送信可能
            if (scc_port_b.rx_ready) ret |= 1;  // 受信データあり
        }
        SCC_RegNumB = 0;
        SCC_RegSetB = 0;
    }
    else if ((adr&7) == 3) {  // 0xE98003: ポートB データ
        // シリアル通信のデータ受信（ポートB）
        BYTE d;
        if (SCC_ReceiveByte(&scc_port_b, &d) == 0) {
            ret = d;
        }
    }
    else if ((adr&7) == 5) {  // 0xE98005: ポートA コントロール
        switch(SCC_RegNumA) {
            case 0:
                ret = 4;  // 送信バッファ空（マウスは常に送信可能）
                break;
            case 3:
                ret = (SCC_DatNum ? 4 : 0);  // 受信データあり
                break;
        }
        SCC_RegNumA = 0;
        SCC_RegSetA = 0;
    }
    else if ((adr&7) == 7) {  // 0xE98007: ポートA データ
        // マウスデータの読み取り
        if (SCC_DatNum) {
            SCC_DatNum--;
            ret = SCC_Dat[SCC_DatNum];
        }
    }
    
    return ret;
}
```

## ステップ4: SCC_IntCheck関数の修正

```c
void SCC_IntCheck(void)
{
    // ポートA（マウス）の割り込みチェック
    if ( (SCC_DatNum) && ((SCC_RegsB[1]&0x18)==0x10) && (SCC_RegsB[9]&0x08) ) {
        IRQH_Int(5, &SCC_Int);
    } else if ( (SCC_DatNum==3) && ((SCC_RegsB[1]&0x18)==0x08) && (SCC_RegsB[9]&0x08) ) {
        IRQH_Int(5, &SCC_Int);
    }
    
    // ポートB（シリアル通信）の割り込みチェック
    if (scc_port_b.connected && scc_port_b.rx_ready) {
        if (((SCC_RegsB[1]&0x18)==0x10) && (SCC_RegsB[9]&0x08)) {
            IRQH_Int(5, &SCC_Int);
        }
    }
}
```

## ステップ5: シリアル通信関数の修正

### 5.1. SCC_SendByte/SCC_ReceiveByteの引数追加

現在の関数:
```c
int SCC_SendByte(BYTE data);
int SCC_ReceiveByte(BYTE* data);
```

修正後:
```c
int SCC_SendByte(SCC_SerialPort* port, BYTE data);
int SCC_ReceiveByte(SCC_SerialPort* port, BYTE* data);
```

### 5.2. 実装例

```c
int SCC_SendByte(SCC_SerialPort* port, BYTE data)
{
    if (!port->connected) return -1;
    pthread_mutex_lock(&port->tx_mutex);
    ssize_t w = write(port->master_fd, &data, 1);
    pthread_mutex_unlock(&port->tx_mutex);
    return (w == 1) ? 0 : -1;
}

int SCC_ReceiveByte(SCC_SerialPort* port, BYTE* data)
{
    if (!port->connected) return -1;
    pthread_mutex_lock(&port->rx_mutex);
    if (port->rx_head != port->rx_tail) {
        *data = port->rx_buffer[port->rx_tail];
        port->rx_tail = (port->rx_tail + 1) % (int)sizeof(port->rx_buffer);
        if (port->rx_head == port->rx_tail) {
            port->rx_ready = 0;
        }
        pthread_mutex_unlock(&port->rx_mutex);
        return 0;
    }
    pthread_mutex_unlock(&port->rx_mutex);
    return -1;
}
```

## ステップ6: API関数の修正

### 6.1. SCC_SetModeの修正

```c
int SCC_SetMode(int imode, const char* config)
{
    SCC_Mode mode = (SCC_Mode)imode;
    
    if (mode == SCC_MODE_MOUSE_ONLY) {
        // マウスは常に有効なので、シリアル通信を無効化するだけ
        SCC_CloseSerial();
        return 0;
    }
    
    // シリアル通信モードを設定（ポートB）
    SCC_CloseSerial();
    scc_port_b.mode = mode;
    
    switch (mode) {
        case SCC_MODE_SERIAL_PTY:
            if (SCC_CreatePTY(&scc_port_b) < 0) return -1;
            break;
        case SCC_MODE_SERIAL_TCP: {
            if (!config) return -1;
            char host[256];
            int port;
            if (sscanf(config, "%255[^:]:%d", host, &port) != 2) return -1;
            if (SCC_ConnectTCP(&scc_port_b, host, port) < 0) return -1;
            break;
        }
        case SCC_MODE_SERIAL_TCP_SERVER: {
            if (!config) return -1;
            int port;
            if (sscanf(config, "%d", &port) != 1) return -1;
            if (SCC_StartTCPServer(&scc_port_b, port) < 0) return -1;
            break;
        }
        case SCC_MODE_SERIAL_FILE:
            if (!config || SCC_OpenFile(&scc_port_b, config) < 0) return -1;
            break;
        default:
            return -1;
    }
    
    // 受信スレッドの開始
    if (mode != SCC_MODE_SERIAL_TCP_SERVER) {
        pthread_mutex_init(&scc_port_b.tx_mutex, NULL);
        pthread_mutex_init(&scc_port_b.rx_mutex, NULL);
        if (pthread_create(&scc_port_b.rx_thread, NULL, SCC_ReceiveThread, &scc_port_b) != 0) {
            SCC_CloseSerial();
            return -1;
        }
        scc_port_b.rx_thread_active = 1;
    }
    
    if (mode == SCC_MODE_SERIAL_TCP_SERVER) {
        pthread_mutex_init(&scc_port_b.tx_mutex, NULL);
        pthread_mutex_init(&scc_port_b.rx_mutex, NULL);
        if (pthread_create(&scc_port_b.accept_thread, NULL, SCC_AcceptThread, &scc_port_b) != 0) {
            SCC_CloseSerial();
            return -1;
        }
    }
    
    return 0;
}
```

### 6.2. SCC_CloseSerialの修正

```c
void SCC_CloseSerial(void)
{
    if (scc_port_b.connected) {
        scc_port_b.connected = 0;
        
        if (scc_port_b.mode == SCC_MODE_SERIAL_TCP_SERVER) {
            pthread_join(scc_port_b.accept_thread, NULL);
            if (scc_port_b.rx_thread_active) {
                pthread_join(scc_port_b.rx_thread, NULL);
                scc_port_b.rx_thread_active = 0;
            }
            pthread_mutex_destroy(&scc_port_b.tx_mutex);
            pthread_mutex_destroy(&scc_port_b.rx_mutex);
        } else if (scc_port_b.mode != SCC_MODE_MOUSE_ONLY) {
            if (scc_port_b.rx_thread_active) {
                pthread_join(scc_port_b.rx_thread, NULL);
                scc_port_b.rx_thread_active = 0;
            }
            pthread_mutex_destroy(&scc_port_b.tx_mutex);
            pthread_mutex_destroy(&scc_port_b.rx_mutex);
        }
        
        if (scc_port_b.master_fd >= 0) {
            close(scc_port_b.master_fd);
            scc_port_b.master_fd = -1;
        }
        if (scc_port_b.server_fd >= 0) {
            close(scc_port_b.server_fd);
            scc_port_b.server_fd = -1;
        }
        if (scc_port_b.client_fd >= 0) {
            close(scc_port_b.client_fd);
            scc_port_b.client_fd = -1;
        }
        
        scc_port_b.slave_path[0] = '\0';
    }
}
```

### 6.3. SCC_GetSlavePathの修正

```c
const char* SCC_GetSlavePath(void)
{
    if (scc_port_b.connected && 
        scc_port_b.mode == SCC_MODE_SERIAL_PTY && 
        scc_port_b.slave_path[0] != '\0') {
        return scc_port_b.slave_path;
    }
    return NULL;
}
```

## ステップ7: SCC_Init関数の修正

```c
void SCC_Init(void)
{
    // マウス関連の初期化
    MouseX = 0;
    MouseY = 0;
    MouseSt = 0;
    SCC_DatNum = 0;
    
    // レジスタの初期化
    SCC_RegNumA = 0;
    SCC_RegSetA = 0;
    SCC_RegNumB = 0;
    SCC_RegSetB = 0;
    SCC_Vector = 0;
    
    // シリアルポートの初期化（ポートBのみ）
    memset(&scc_port_b, 0, sizeof(scc_port_b));
    scc_port_b.mode = SCC_MODE_MOUSE_ONLY;  // 初期状態ではシリアル通信無効
    scc_port_b.master_fd = -1;
    scc_port_b.server_fd = -1;
    scc_port_b.client_fd = -1;
    scc_port_b.rx_thread_active = 0;
    scc_port_b.baud_rate = 9600;
    scc_port_b.data_bits = 8;
    scc_port_b.stop_bits = 1;
    scc_port_b.parity = 0;
    scc_port_b.slave_path[0] = '\0';
}
```

## ステップ8: 不要なコードの削除

以下のコードは不要になるので削除します:

1. `scc_port_a`に関する全てのコード（`scc_port_b`に置き換え済み）
2. マウスキュー関連のコード（ダブルクリック修正で削除済み）
   - `SCC_MouseQueue`
   - `SCC_MouseQHead`, `SCC_MouseQTail`, `SCC_MouseQCount`
   - `SCC_MouseQEnqueue`, `SCC_MouseQDequeue`関数

## ステップ9: テスト

各ステップの実装後、以下をテストします:

1. **マウスのみ**: シリアル通信無効でマウスが正常に動作するか
2. **シリアル通信のみ**: マウスを使わずにシリアル通信が動作するか
3. **同時動作**: マウスとシリアル通信を同時に使用できるか
4. **ダブルクリック**: 全ての状況でダブルクリックが正常に動作するか

## まとめ

この実装により、X68000実機と同様に:
- ポートA: マウス専用
- ポートB: シリアル通信専用
- 両ポートが独立して同時に動作

という構成が実現されます。
