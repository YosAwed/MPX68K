# X68000実機準拠のマウス・シリアル通信同時動作実装計画

## 1. X68000実機の仕様

### 1.1. ハードウェア構成

X68000実機では、Z8530 SCC（Serial Communication Controller）が以下のように使用されています:

- **SCCポートA**: マウス専用
- **SCCポートB**: RS-232Cシリアル通信専用

この2つのポートは**独立して同時に動作**します。

### 1.2. アドレスマップ

X68000のSCCレジスタは以下のアドレスにマップされています:

```
0xE98001: SCC ポートB コントロール
0xE98003: SCC ポートB データ
0xE98005: SCC ポートA コントロール
0xE98007: SCC ポートA データ
```

現在のMPX68Kのコードでは:
```c
if ((adr&7) == 1)  // ポートB コントロール
if ((adr&7) == 3)  // ポートB データ
if ((adr&7) == 5)  // ポートA コントロール
if ((adr&7) == 7)  // ポートA データ
```

## 2. 現在のMPX68Kの問題点

### 2.1. 設計上の問題

現在の実装では、`scc_port_a.mode`という変数で**ポートAの動作モードを切り替える**設計になっています。

```c
if (scc_port_a.mode == SCC_MODE_MOUSE_ONLY) {
    // マウス処理
} else {
    // シリアル通信処理
}
```

この設計では、ポートAをマウスとシリアル通信で排他的に使用することになり、実機の仕様と異なります。

### 2.2. 実機との違い

| 項目 | X68000実機 | 現在のMPX68K |
|------|-----------|-------------|
| ポートA | マウス専用 | マウスまたはシリアル通信（排他） |
| ポートB | シリアル通信専用 | 未使用 |
| 同時動作 | 可能 | 不可能 |

## 3. 実装計画

### 3.1. 基本方針

X68000実機の仕様に合わせて、以下のように修正します:

1. **ポートA**: マウス専用（固定）
2. **ポートB**: シリアル通信専用（固定）
3. 両ポートを独立して同時に動作させる

### 3.2. データ構造の変更

#### 現在の構造
```c
static SCC_SerialPort scc_port_a;  // ポートA（マウスまたはシリアル）
static SCC_SerialPort scc_port_b;  // 未使用
```

#### 修正後の構造
```c
// ポートA: マウス専用（既存のマウス関連変数を使用）
// 既存: MouseX, MouseY, MouseSt, SCC_Dat[], SCC_DatNum など

// ポートB: シリアル通信専用
static SCC_SerialPort scc_port_b;  // シリアル通信用に使用
```

### 3.3. 関数の修正

#### 3.3.1. SCC_Write関数

**現在の実装**:
```c
if ((adr&7) == 1) {  // ポートB コントロール
    if (SCC_RegNumB == 5) {
        if (scc_port_a.mode == SCC_MODE_MOUSE_ONLY) {
            // マウス処理
        } else {
            // シリアル通信処理
        }
    }
}
```

**修正後の実装**:
```c
if ((adr&7) == 1) {  // ポートB コントロール
    if (SCC_RegNumB == 5) {
        // ポートBはシリアル通信専用
        if ((data & 2) && scc_port_b.connected) {
            scc_port_b.tx_ready = 1;
        }
    }
}
else if ((adr&7) == 3) {  // ポートB データ
    // シリアル通信のデータ送信
    if (scc_port_b.connected) {
        SCC_SendByte_PortB(data);
    }
}
else if ((adr&7) == 5) {  // ポートA コントロール
    if (SCC_RegNumA == 5) {
        // ポートAはマウス専用
        int rtsRising = (!(SCC_RegsA[5]&2)) && (data&2);
        int rxEnabled = (SCC_RegsA[3]&1);
        if (rtsRising && rxEnabled && (!SCC_DatNum)) {
            Mouse_SetData();
            SCC_DatNum = 3;
            SCC_Dat[2] = MouseSt;
            SCC_Dat[1] = (BYTE)MouseX;
            SCC_Dat[0] = (BYTE)MouseY;
        }
    }
}
else if ((adr&7) == 7) {  // ポートA データ
    // ポートAはマウス専用なので、データ書き込みは無視
}
```

#### 3.3.2. SCC_Read関数

**修正後の実装**:
```c
if ((adr&7) == 1) {  // ポートB コントロール
    if (!SCC_RegNumB) {
        ret = 0;
        if (scc_port_b.tx_ready) ret |= 4;  // 送信可能
        if (scc_port_b.rx_ready) ret |= 1;  // 受信データあり
    }
}
else if ((adr&7) == 3) {  // ポートB データ
    // シリアル通信のデータ受信
    BYTE d;
    if (SCC_ReceiveByte_PortB(&d) == 0) {
        ret = d;
    }
}
else if ((adr&7) == 5) {  // ポートA コントロール
    switch(SCC_RegNumA) {
        case 0:
            ret = 4;  // 送信バッファ空（マウスは常に送信可能）
            break;
        case 3:
            ret = (SCC_DatNum ? 4 : 0);  // 受信データあり
            break;
    }
}
else if ((adr&7) == 7) {  // ポートA データ
    // マウスデータの読み取り
    if (SCC_DatNum) {
        SCC_DatNum--;
        ret = SCC_Dat[SCC_DatNum];
    }
}
```

#### 3.3.3. SCC_IntCheck関数

**修正後の実装**:
```c
void SCC_IntCheck(void)
{
    // ポートA（マウス）の割り込みチェック
    if ( (SCC_DatNum) && ((SCC_RegsB[1]&0x18)==0x10) && (SCC_RegsB[9]&0x08) ) {
        IRQH_Int(5, &SCC_Int);
    } else if ( (SCC_DatNum==3) && ((SCC_RegsB[1]&0x18)==0x08) && (SCC_RegsB[9]&0x08) ) {
        IRQH_Int(5, &SCC_Int);
    }
    
    // ポートB（シリアル通信）の割り込みチェック
    if (scc_port_b.connected) {
        if (scc_port_b.rx_ready && ((SCC_RegsB[1]&0x18)==0x10) && (SCC_RegsB[9]&0x08)) {
            IRQH_Int(5, &SCC_Int);
        }
    }
}
```

### 3.4. API関数の変更

#### 現在のAPI
```c
int SCC_SetMode(int mode, const char* config);
```

#### 修正後のAPI
```c
// ポートBのシリアル通信モードを設定
int SCC_SetSerialMode(int mode, const char* config);

// ポートBのシリアル通信を閉じる
void SCC_CloseSerial(void);

// ポートAは常にマウスモードなので、モード設定関数は不要
```

### 3.5. SCCManagerの変更

Swift側のSCCManagerも修正が必要です:

```swift
public enum SCCSerialMode: Int32 {
    case disabled = 0  // シリアル通信無効
    case serialPTY = 1
    case serialTCP = 2
    case serialFile = 3
    case serialTCPServer = 4
}

public class SCCManager: ObservableObject {
    @Published public var isSerialConnected: Bool = false
    @Published public var currentSerialMode: SCCSerialMode = .disabled
    
    // マウスは常に有効なので、マウス関連の状態管理は不要
    
    public func createPTY() -> Bool {
        let result = SCC_SetSerialMode(SCCSerialMode.serialPTY.rawValue, nil)
        if result == 0 {
            currentSerialMode = .serialPTY
            isSerialConnected = true
            return true
        }
        return false
    }
    
    public func disconnectSerial() {
        SCC_CloseSerial()
        isSerialConnected = false
        currentSerialMode = .disabled
    }
    
    // マウスは常に有効なので、マウスモード設定関数は削除
}
```

## 4. 実装の優先順位

### フェーズ1: 基本構造の変更（最優先）
1. ポートAをマウス専用に固定
2. ポートBをシリアル通信専用に変更
3. `scc_port_a`を`scc_port_b`に置き換え
4. `SCC_Write`/`SCC_Read`関数でポートA/Bを正しく処理

### フェーズ2: ダブルクリック修正の適用
1. ポートAのマウス処理に、既に作成した修正を適用
2. `(!SCC_DatNum)`条件を維持

### フェーズ3: シリアル通信機能の移行
1. 全てのシリアル通信処理をポートBに移行
2. PTY、TCP、ファイルモードの動作確認

### フェーズ4: API・UI層の調整
1. `SCC_SetMode`を`SCC_SetSerialMode`に変更
2. SCCManagerの修正
3. UIの調整（マウスは常に有効と表示）

## 5. 後方互換性の考慮

既存のコードとの互換性を保つため、以下のラッパー関数を提供できます:

```c
// 後方互換性のためのラッパー関数
int SCC_SetMode(int mode, const char* config) {
    if (mode == 0) {  // SCC_MODE_MOUSE_ONLY
        // マウスは常に有効なので、シリアル通信を無効化
        SCC_CloseSerial();
        return 0;
    } else {
        // シリアル通信モードを設定
        return SCC_SetSerialMode(mode, config);
    }
}
```

## 6. テスト計画

### 6.1. マウス機能のテスト
- カーソル移動
- シングルクリック
- ダブルクリック
- ドラッグ
- シリアル通信有効時も上記が動作すること

### 6.2. シリアル通信のテスト
- PTYモード
- TCPクライアントモード
- TCPサーバーモード
- ファイルモード
- マウス動作中も上記が動作すること

### 6.3. 同時動作のテスト
- マウスを動かしながらシリアル通信
- シリアル通信中にダブルクリック

## 7. 実装上の注意点

### 7.1. レジスタの分離

現在、`SCC_RegsA`と`SCC_RegsB`が混在して使用されています。実機では:
- `SCC_RegsA`: ポートAのレジスタ
- `SCC_RegsB`: ポートBのレジスタ

これらを正しく分離して使用する必要があります。

### 7.2. 割り込みベクタ

SCC_Vectorは両ポートで共有されるため、割り込み発生時にどちらのポートからの割り込みかを識別する必要があります。

### 7.3. スレッドの管理

シリアル通信の受信スレッドは、ポートBに対してのみ動作するようにします。

## 8. まとめ

この実装計画により、X68000実機と同様に、マウスとシリアル通信を同時に使用できるようになります。

**主な変更点**:
1. ポートAをマウス専用に固定
2. ポートBをシリアル通信専用に変更
3. 両ポートを独立して動作させる
4. ダブルクリック修正も同時に適用

**利点**:
- 実機の仕様に準拠
- マウスとシリアル通信の同時使用が可能
- ダブルクリックの問題も解決
- コードの見通しが良くなる
