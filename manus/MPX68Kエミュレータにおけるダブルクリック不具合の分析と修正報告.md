# MPX68Kエミュレータにおけるダブルクリック不具合の分析と修正報告

## 1. はじめに

この度は、MPX68KエミュレータにおけるVisual Shellのダブルクリックが正常に機能しない問題について、分析のご依頼をいただきありがとうございます。本レポートでは、ソースコードの比較分析を通じて特定した不具合の原因と、その修正内容について詳細に報告いたします。

## 2. 問題の概要

ご指摘の通り、MPX68Kエミュレータでは、マウスのカーソル移動、シングルクリック、ドラッグといった基本的なマウス操作は正常に動作するものの、短時間での連続クリック（ダブルクリック）がVisual Shell上で認識されないという問題が発生していました。X68000の時代にはダブルクリックという概念がOSレベルで標準化されていなかったため、アプリケーション側が「短時間に行われる2回のシングルクリック」を検出することで、この機能を実現しています。正常に動作していたオリジナル版の`px68k`と比較して、シリアル通信機能が追加された`MPX68K`でこの問題が発生していることから、`scc.c`（SCC: シリアルコミュニケーションコントローラ）の実装が原因であると推測されました。

## 3. 原因分析

オリジナル版`px68k`の`scc.c`と、問題が発生している`MPX68K`の`scc.c`を比較分析した結果、不具合の根本原因はマウスイベントのデータを生成するタイミングを制御するロジックの差異にあることを特定いたしました。

### 3.1. マウスデータ生成の制御ロジック

X68000の実機では、マウスからのデータはSCCを介して取得されます。エミュレータではこの動作を模倣しており、`SCC_Write`関数内でホストOSのマウスイベントを検出し、エミュレートされたSCCのデータレジスタに値をセットします。X68000側のソフトウェアは、RTS信号を制御してこのデータレジスタをポーリングし、マウスの状態（ボタンの押下状態や移動量）を読み取ります。

#### オリジナル版（px68k）のロジック

オリジナル版の`scc.c`では、マウスデータを生成する条件が非常に厳密に定義されています。

```c
// in SCC_Write()
if ( (!(SCC_RegsB[5]&2))&&(data&2)&&(SCC_RegsB[3]&1)&&(!SCC_DatNum) )
{
    Mouse_SetData();
    SCC_DatNum = 3;
    SCC_Dat[2] = MouseSt;
    SCC_Dat[1] = MouseX;
    SCC_Dat[0] = MouseY;
}
```

このコードの`(!SCC_DatNum)`という条件が極めて重要です。`SCC_DatNum`は、まだ読み取られていないマウスデータのバイト数を示すカウンタです。この条件により、**X68000側が前回のマウスデータを完全に読み取り終える（`SCC_DatNum`が0になる）まで、次のマウスデータが生成されない**ことが保証されます。これにより、クリックの「ダウン」と「アップ」といった連続するイベントが、一つずつ順番にX68000側に通知されます。

#### MPX68K版のロジック

一方、`MPX68K`ではシリアル通信機能の追加に伴い、マウスイベントをキューに溜める機能が実装されました。その過程で、上記の制御ロジックが以下のように変更されています。

```c
// in SCC_Write()
if (rtsRising && rxEnabled) {
    Mouse_SetData(); // 常にMouse_SetData()が呼ばれる
    if (!SCC_DatNum) {
        // データを即座にセット
    } else {
        // データをキューに追加
        SCC_MouseQEnqueue(...);
    }
}
```

最大の問題点は、`Mouse_SetData()`の呼び出しが`!SCC_DatNum`の条件分岐の外に出されてしまったことです。これにより、X68000側が前回のデータを読み取っている最中であっても、ホストOS側で新たなマウスイベントが発生すると、その最新の状態が即座に`Mouse_SetData()`によって取得されてしまいます。

### 3.2. ダブルクリックが失敗するシナリオ

このロジックの変更が、なぜダブルクリックの失敗を引き起こすのかを以下に示します。

1.  ユーザーが高速で1回目のクリックを行う（ボタン**ダウン** → **アップ**）。
2.  X68000側のポーリングが追いつかず、この2つのイベントが次のポーリングまでの間に発生したとします。
3.  `Mouse_Event()`関数により、エミュレータ内部のマウス状態(`MouseStat`)は、`1`（ダウン）になった直後に`0`（アップ）に更新されます。
4.  その後、ユーザーが2回目のクリックを行う（ボタン**ダウン**）。`MouseStat`は再び`1`になります。
5.  ここでX68000側がRTS信号を上げてポーリングを行うと、`MPX68K`の`SCC_Write`関数が呼ばれます。
6.  `Mouse_SetData()`が**無条件に**呼び出され、その時点での最新のマウス状態（2回目のクリックダウン状態）のみが取得されます。1回目のクリックにおける「ダウン」と「アップ」のイベントは、`Mouse_SetData()`が呼び出される前に上書きされてしまい、失われます。

結果として、X68000側は2回目のクリックしか認識できず、短時間での連続クリックを検出できないため、ダブルクリックが成立しなくなります。

## 4. 修正内容

この問題を解決するため、`MPX68K`の`scc.c`に対して、オリジナル版の厳密なデータ生成ロジックを復元する修正を行いました。この修正は、ご要望の通り、既存のカーソル移動、シングルクリック、ドラッグといった正常に動作している機能に影響を与えません。

修正のポイントは以下の2点です。

1.  **`SCC_Write`関数の修正**:
    マウスデータを生成するロジックを、オリジナル版と同様に`!SCC_DatNum`の条件が満たされる場合にのみ実行するように戻しました。これにより、前回のデータが読み取られるまで新しいデータは生成されなくなり、イベントの順序が保証されます。不具合の原因となっていたキューイング機能は、ダブルクリック検出の妨げになるため削除しました。

2.  **`SCC_IntCheck`関数の修正**:
    `SCC_Write`関数からキューイング機能を削除したことに伴い、`SCC_IntCheck`関数内に残っていたキューからのデータ取り出し処理も削除し、コードの整合性を保ちました。

修正後のコードは、マウス処理に関してはオリジナル版と実質的に同じ動作となり、シリアル通信機能とは独立して、安定したマウスイベントの通知を保証します。

## 5. 提供ファイル

分析結果に基づき、以下の2つのファイルを作成いたしました。

1.  **`scc_FIXED.c`**: 修正を適用した`scc.c`の完全なソースコードです。このファイルをプロジェクトの対応する場所に上書きしていただくことで、問題が解決されます。
2.  **`fix_diff.txt`**: 元の`scc.c`と修正後の`scc_FIXED.c`の差分（diff）です。具体的な変更箇所をレビューする際にご利用いただけます。

これらのファイルは、本メッセージに添付しております。

## 6. 結論

本件の不具合は、シリアル通信機能の追加に伴うマウスイベント処理ロジックの変更が、意図せずして高速な連続クリックイベントの取りこぼしを発生させていたことに起因します。提案する修正は、このロジックをオリジナル版の安定した動作に戻すものであり、これによりダブルクリックの問題を解決しつつ、他のすべてのマウス機能とシリアル通信機能は維持されます。

ご不明な点がございましたら、お気軽にお尋ねください。
