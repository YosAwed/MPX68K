-			ret = SCC_Dat[SCC_DatNum];
-		}
-	}
-	else if ((adr&7) == 5)
-	{
-		switch(SCC_RegNumA)
-		{
-		case 0:
-			ret = 4;			// Á÷¿®¥Ð¥Ã¥Õ¥¡¶õ¡ÊXna¡Ë
-			break;
-		case 3:
-			ret = ((SCC_DatNum)?4:0);
-			break;
-		}
-		SCC_RegNumA = 0;
-		SCC_RegSetA = 0;
-	}
-	return ret;
+int SCC_SetMode(int imode, const char* config)
+{
+    SCC_Mode mode = (SCC_Mode)imode;
+    SCC_CloseSerial(); scc_port_a.mode = mode;
+    switch (mode) {
+        case SCC_MODE_MOUSE_ONLY: return 0;
+        case SCC_MODE_SERIAL_PTY: if (SCC_CreatePTY() < 0) return -1; break;
+        case SCC_MODE_SERIAL_TCP: {
+            if (!config) return -1; char host[256]; int port;
+            if (sscanf(config, "%255[^:]:%d", host, &port) != 2) return -1;
+            if (SCC_ConnectTCP(host, port) < 0) return -1; break; }
+        case SCC_MODE_SERIAL_TCP_SERVER: {
+            if (!config) return -1; int port;
+            if (sscanf(config, "%d", &port) != 1) return -1;
+            if (SCC_StartTCPServer(port) < 0) return -1; break; }
+        case SCC_MODE_SERIAL_FILE: if (!config || SCC_OpenFile(config) < 0) return -1; break;
+        default: return -1;
+    }
+    if (mode != SCC_MODE_MOUSE_ONLY && mode != SCC_MODE_SERIAL_TCP_SERVER) {
+        pthread_mutex_init(&scc_port_a.tx_mutex, NULL);
+        pthread_mutex_init(&scc_port_a.rx_mutex, NULL);
+        if (pthread_create(&scc_port_a.rx_thread, NULL, SCC_ReceiveThread, &scc_port_a) != 0) { SCC_CloseSerial(); return -1; }
+        scc_port_a.rx_thread_active = 1;
+    }
+    
+    // TCPサーバーモードの場合はaccept待機スレッドのみ作成（受信スレッドはクライアント接続後）
+    if (mode == SCC_MODE_SERIAL_TCP_SERVER) {
+        pthread_mutex_init(&scc_port_a.tx_mutex, NULL);
+        pthread_mutex_init(&scc_port_a.rx_mutex, NULL);
+        
+        // シリアル通信の標準設定でSCCレジスタを初期化
+        // 9600 baud, 8 data bits, 1 stop bit, no parity
+        SCC_RegsB[1] = 0x10;  // 受信割り込みイネーブル
+        SCC_RegsB[3] = 0xC1;  // 受信イネーブル, 8ビット
+        SCC_RegsB[4] = 0x44;  // x16クロック, 1ストップビット, パリティなし  
+        SCC_RegsB[5] = 0x6A;  // 送信イネーブル, 8ビット, DTR, RTS
+        SCC_RegsB[9] = 0x08;  // マスター割り込みイネーブル
+        SCC_RegsB[11] = 0x50; // 送受信共にボーレートジェネレータを使用
+        SCC_RegsB[12] = 0x18; // 9600baud用の下位バイト
+        SCC_RegsB[13] = 0x00; // 9600baud用の上位バイト
+        SCC_RegsB[14] = 0x01; // ボーレートジェネレータイネーブル
+        
+        printf("SCC_SetMode: Initialized SCC registers for TCP server mode\n");
+        printf("SCC_SetMode: About to create accept thread - connected=%d, server_fd=%d\n", scc_port_a.connected, scc_port_a.server_fd);
+        if (pthread_create(&scc_port_a.accept_thread, NULL, SCC_AcceptThread, &scc_port_a) != 0) { 
+            printf("SCC_SetMode: Failed to create accept thread\n");
+            SCC_CloseSerial(); 
+            return -1; 
+        }
+        printf("SCC_SetMode: Accept thread created successfully\n");
+    }
+    return 0;
+}
+
+void SCC_CloseSerial(void)
+{
+    if (scc_port_a.connected) {
+        scc_port_a.connected = 0;
+        
+        if (scc_port_a.mode == SCC_MODE_SERIAL_TCP_SERVER) {
+            // TCPサーバーモードの場合
+            
+            // accept待機スレッドを終了
+            pthread_join(scc_port_a.accept_thread, NULL);
+            
+            // クライアントが接続されている場合は受信スレッドも終了
+            if (scc_port_a.rx_thread_active) {
+                pthread_join(scc_port_a.rx_thread, NULL);
+                scc_port_a.rx_thread_active = 0;
+            }
+            
+            pthread_mutex_destroy(&scc_port_a.tx_mutex);
+            pthread_mutex_destroy(&scc_port_a.rx_mutex);
+        } else if (scc_port_a.mode != SCC_MODE_MOUSE_ONLY) {
+            // 他のシリアルモードの場合
+            if (scc_port_a.rx_thread_active) {
+                pthread_join(scc_port_a.rx_thread, NULL);
+                scc_port_a.rx_thread_active = 0;
+            }
+            pthread_mutex_destroy(&scc_port_a.tx_mutex);
+            pthread_mutex_destroy(&scc_port_a.rx_mutex);
+        }
+        
+        if (scc_port_a.master_fd >= 0) { close(scc_port_a.master_fd); scc_port_a.master_fd = -1; }
+        
+        // TCPサーバー関連のソケットもクローズ
+        if (scc_port_a.server_fd >= 0) { close(scc_port_a.server_fd); scc_port_a.server_fd = -1; }
+        if (scc_port_a.client_fd >= 0) { close(scc_port_a.client_fd); scc_port_a.client_fd = -1; }
+        
+        // Clear slave path
+        scc_port_a.slave_path[0] = '\0';
+    }
+}
+
+const char* SCC_GetSlavePath(void)
+{
+    if (scc_port_a.connected && scc_port_a.mode == SCC_MODE_SERIAL_PTY && scc_port_a.slave_path[0] != '\0') {
+        return scc_port_a.slave_path;
+    }
+    return NULL;
+}
+
+int SCC_SendByte(BYTE data)
+{
+    if (!scc_port_a.connected || scc_port_a.mode == SCC_MODE_MOUSE_ONLY) return -1;
+    printf("SCC_SendByte: Sending byte %02X ('%c') to fd %d, mode=%d\n", 
+           data, (data >= 32 && data < 127) ? data : '.', scc_port_a.master_fd, scc_port_a.mode);
+    pthread_mutex_lock(&scc_port_a.tx_mutex);
+    ssize_t w = write(scc_port_a.master_fd, &data, 1);
+    pthread_mutex_unlock(&scc_port_a.tx_mutex);
+    printf("SCC_SendByte: Write result = %zd\n", w);
+    return (w == 1) ? 0 : -1;
+}
+
+int SCC_ReceiveByte(BYTE* data)
+{
+    if (!scc_port_a.connected || scc_port_a.mode == SCC_MODE_MOUSE_ONLY) return -1;
+    pthread_mutex_lock(&scc_port_a.rx_mutex);
+    if (scc_port_a.rx_head != scc_port_a.rx_tail) {
+        *data = scc_port_a.rx_buffer[scc_port_a.rx_tail];
+        printf("SCC_ReceiveByte: Read byte %02X ('%c') from buffer\n", *data, (*data >= 32 && *data < 127) ? *data : '.');
+        scc_port_a.rx_tail = (scc_port_a.rx_tail + 1) % (int)sizeof(scc_port_a.rx_buffer);
+        if (scc_port_a.rx_head == scc_port_a.rx_tail) {
+            scc_port_a.rx_ready = 0;
+            printf("SCC_ReceiveByte: Buffer empty, rx_ready=0\n");
+        } else {
+            printf("SCC_ReceiveByte: More data available, rx_ready=1\n");
+        }
+        pthread_mutex_unlock(&scc_port_a.rx_mutex); return 0;
+    }
+    printf("SCC_ReceiveByte: No data available (head=%d, tail=%d)\n", scc_port_a.rx_head, scc_port_a.rx_tail);
+    pthread_mutex_unlock(&scc_port_a.rx_mutex); return -1;
+}
+
+void SCC_Init(void)
+{
+    MouseX = 0; MouseY = 0; MouseSt = 0;
+    SCC_RegNumA = SCC_RegSetA = SCC_RegNumB = SCC_RegSetB = 0; SCC_Vector = 0; SCC_DatNum = 0;
+
+    // Initialize mouse packet latch queue
+    SCC_MouseQHead = 0; SCC_MouseQTail = 0; SCC_MouseQCount = 0;
+    memset(SCC_MouseQueue, 0, sizeof(SCC_MouseQueue));
+
+    memset(&scc_port_a, 0, sizeof(scc_port_a)); memset(&scc_port_b, 0, sizeof(scc_port_b));
+    scc_port_a.mode = SCC_MODE_MOUSE_ONLY; scc_port_a.master_fd = -1;
+    scc_port_a.server_fd = -1; scc_port_a.client_fd = -1;  // TCPサーバー関連フィールドを初期化
+    scc_port_a.rx_thread_active = 0;  // 受信スレッド状態を初期化
+    scc_port_a.baud_rate = 9600; scc_port_a.data_bits = 8; scc_port_a.stop_bits = 1; scc_port_a.parity = 0;
+    scc_port_a.slave_path[0] = '\0';  // Explicitly clear slave path
+}
+
+void FASTCALL SCC_Write(DWORD adr, BYTE data)
+{
+    if (adr>=0xe98008) return;
+    if ((adr&7) == 1) {
+        if (SCC_RegSetB) {
+            if (SCC_RegNumB == 5) {
+                if (scc_port_a.mode == SCC_MODE_MOUSE_ONLY) {
+                    // Detect RTS 0->1 with receiver enabled
+                    int rtsRising = (!(SCC_RegsB[5]&2)) && (data&2);
+                    int rxEnabled = (SCC_RegsB[3]&1);
+                    if (rtsRising && rxEnabled) {
+                        // Latch current mouse state
+                        Mouse_SetData();
+                        if (!SCC_DatNum) {
+                            // Publish immediately
+                            SCC_DatNum = 3;
+                            SCC_Dat[2] = MouseSt;        // Status first
+                            SCC_Dat[1] = (BYTE)MouseX;   // X
+                            SCC_Dat[0] = (BYTE)MouseY;   // Y
+                        } else {
+                            // A packet is still pending; enqueue latest
+                            SCC_MouseQEnqueue(MouseSt, (BYTE)MouseX, (BYTE)MouseY);
+                        }
+                    }
+                } else {
+                    if ((data & 2) && scc_port_a.connected) { scc_port_a.tx_ready = 1; }
+                }
+            } else if (SCC_RegNumB == 2) {
+                SCC_Vector = data;
+            }
+            SCC_RegSetB = 0; SCC_RegsB[SCC_RegNumB] = data; SCC_RegNumB = 0;
+        } else {
+            if (!(data&0xf0)) { data &= 15; SCC_RegSetB = 1; SCC_RegNumB = data; }
+            else { SCC_RegSetB = 0; SCC_RegNumB = 0; }
+        }
+    } else if ((adr&7) == 3) {
+        if (scc_port_a.mode != SCC_MODE_MOUSE_ONLY && scc_port_a.connected) { 
+            printf("SCC_Write: Port A data register write (adr=%08X, data=%02X)\n", adr, data);
+            SCC_SendByte(data); 
+        }
+    } else if ((adr&7) == 5) {
+        if (SCC_RegSetA) {
+            SCC_RegSetA = 0; switch (SCC_RegNumA) { case 2: SCC_RegsB[2] = data; SCC_Vector = data; break; case 9: SCC_RegsB[9] = data; break; }
+        } else {
+            data &= 15; if (data) { SCC_RegSetA = 1; SCC_RegNumA = data; } else { SCC_RegSetA = 0; SCC_RegNumA = 0; }
+        }
+    } else if ((adr&7) == 7) {
+        if (scc_port_a.mode != SCC_MODE_MOUSE_ONLY && scc_port_a.connected) { 
+            printf("SCC_Write: Port B data register write (adr=%08X, data=%02X)\n", adr, data);
+            SCC_SendByte(data); 
+        }
+    }
+}
+
+BYTE FASTCALL SCC_Read(DWORD adr)
+{
+    BYTE ret = 0; if (adr>=0xe98008) return ret;
+    if ((adr&7) == 1) {
+        if (!SCC_RegNumB) {
+            if (scc_port_a.mode == SCC_MODE_MOUSE_ONLY) { ret = (SCC_DatNum ? 1 : 0); }
+            else { ret = 0; if (scc_port_a.tx_ready) ret |= 4; if (scc_port_a.rx_ready) ret |= 1; }
+        }
+        SCC_RegNumB = 0; SCC_RegSetB = 0;
+    } else if ((adr&7) == 3) {
+        if (scc_port_a.mode == SCC_MODE_MOUSE_ONLY) {
+            if (SCC_DatNum) { SCC_DatNum--; ret = SCC_Dat[SCC_DatNum]; }
+        } else {
+            BYTE d; 
+            if (SCC_ReceiveByte(&d) == 0) {
+                ret = d;
+                printf("SCC_Read: Port A data read, returning byte %02X ('%c')\n", ret, (ret >= 32 && ret < 127) ? ret : '.');
+            } else {
+                printf("SCC_Read: Port A data read, but no data available\n");
+            }
+        }
+    } else if ((adr&7) == 5) {
+        switch (SCC_RegNumA) {
+            case 0:
+                if (scc_port_a.mode == SCC_MODE_MOUSE_ONLY) ret = 4;
+                else { ret = 0; if (scc_port_a.tx_ready) ret |= 4; if (scc_port_a.rx_ready) ret |= 1; }
+                break;
+            case 3:
+                if (scc_port_a.mode == SCC_MODE_MOUSE_ONLY) ret = (SCC_DatNum ? 4 : 0);
+                else ret = (scc_port_a.rx_ready ? 4 : 0);
+                break;
+        }
+        SCC_RegNumA = 0; SCC_RegSetA = 0;
+    } else if ((adr&7) == 7) {
+        if (scc_port_a.mode != SCC_MODE_MOUSE_ONLY) { 
+            BYTE d; 
+            if (SCC_ReceiveByte(&d) == 0) {
+                ret = d;
+                printf("SCC_Read: Port B data read, returning byte %02X ('%c')\n", ret, (ret >= 32 && ret < 127) ? ret : '.');
+            } else {
+                printf("SCC_Read: Port B data read, but no data available\n");
+            }
+        }
+    }
+    return ret;
 }
